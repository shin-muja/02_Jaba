Java 프로젝트 명명규칙
- 대소문자 구분없이 가능
- 대문자 사용을 권장
- 회사의 기준에 따르기

project 만들시
Module 항목
Create module-info.java file 체크 해제 권장

src 폴더
만든 자바 코드 파일들을 모아두는곳

Package
관련된 코드들의 묶음 == 파일들의 묶음 == 폴더

edu.kh.basic : 사이의 '.'는 하위를 뜻함

웹개발 시
패키지명의 명명규칙
 - 소문자
 - 도메인 이름 역순 : cafe.naver.com -> 패키지 명 : com.naver.cafe
 - 최소 3레벨

class 파일 명명규칙
 - 대문자 시작
 - 단어 구분 시
각 단어의 첫글자 대문자 표기
 - 특수문자 금지

문자형 대입은 ''만 가능
문자열 대입은 "" 만 가능

String 참조형 변수


자동 형변환
값의 범위가 더 큰 자료형으로 변환

float 값의 범위 : 3.4 *10의 38승

long이 byte가 더 크지만 값의 범위는 더 작다


배열 선언 : 메모리에 배열을 참조하는 변수 공간을 만듬 ( 값 직접 저장X, 배열의 주소를 저장)

기본자료형(Primitive type) : int, double, boolean 같은 일반 자료형은 stack 영역에 있음

참조자료형(Reference type) : 배열(array), 객체(Object), Stirng은 heap영역에 할당

배열의 변수는 참조변수로 heap영역에 생성된 배열의 주소를 참조한다
new 연산자에 할단된 객체나 배열은 heap영역에 할당된다

heap영역에 할당된 공간은 '절대' 비어있을 수 없다.
-> 최초 할당 시 JVM 기본 값이 자동 저장된다
(boolean은 false, 나머지 0, 참조형 null)

JAVA에서 배열 리터럴 표기법은 {}



OOP 
객체 : 독립적으로 각각 구분해서 인식할 수 있는 모든 것
-물건, 물체, 요소, 대상...

지향 : 어떠한 것을 목표로 함.

객체 지향 -> 독립적으로 각각 구분해서 인식할수 있게 끔 하는 것을 목표로 함

3 + 1대특징

캡슐화 : 요소들을 모으고 외부로부터 보호하는 특징

상속 : 아버지의 성을 자식에게 물려받는듯한 특징, 부모 클래스의 객체를 자식클래스가 물려받아 사용

☆다형성 : 다양한 형태를 지니는 성질, 형태를 바꿀수 있음 

+

추상화 : 공통된 코드만 작성 (선언은 선언별로, 연산은 연산별로)


객체 : 속성(값, data)과 기능(동작, 행동)이 다른것들과 구분되어 식별 가능한 것

사람으로 예시
속성 : 이름, 나이, 생년월일 등등
기능 : 밥먹기, 걷는다, 잠잔다 등등

class : 객체의 특성( 속성, 기능)에 대한 정의를 한 것
필드, 생성자, 메서드로 이루어짐 / 생성자는 또하나의 메서드와 같다
** 추상화, 캡슐화 ** 반드시 적용되어야 함

추상화(absraction)

캡슐화의 이유 : 데이터 물결성, getter와 setter를 통한 데이터 조건이나 들어온 값에 따른 변화들을 실행 시키고 데이터 유효성 검사를 할 수 있다.
데이터를 직접접근이 가능 시 이러한 유효성


class 접근 제한자

+ public : 같은 패키지 내 O, 전체 O
- default : 같은 패키지 내 O, 전체 X


*** 자바에서의 각 변수의 특징 ***

1. 클래스변수 - static으로 선언된 멤버변수
2. 인스턴스 변수 - new heap 에 할당되는 객체(인스턴스)
3. 지역변수 - 메서드, 제어문 변수 stack

필드 접근 제한자
+ public : 해당 클래스 내부 O, 같은 패키지 내 O, 후손 클래스 내 O, 전체 O
# protected : 해당 클래스 내부 O, 같은 패키지 내 O, 후손 클래스 내 O, 전체 X
! (default) : 해당 클래스 내부 O, 같은 패키지 내 O, 후손 클래스 내 X, 전체 X
- private해당 클래스 내부 O, 같은 패키지 내 X, 후손 클래스 내 X, 전체 X
앞 표시는 클래스 다이어그램외에도 사용해주는 표시들

생성자 반환형이 없고 클래스명과 대소문자 모두 일치해야함

CRUD(Create, Read, Updata, Delete) : 데이터 삽입, 조회, 수정, 삭제를 의미

자바의 컬렉션 : 자바에서 제공하는 자료구조 모음
List, Set, Map
배열과 달리 길이, 크기를 조정가능
인터페이스로만 구성됨 해당 자료구조에 맞는 인터페이스가 구축되어있음

컬렉션 주요 인터페이스 특징 중요
List 계열 구현 클래스 - ArrayList, Vector, LinkedList
List(나열) - 기본적으로 배열모양을 가짐, 순서 유지가능,  중복 저장가능(리스트 안에 있는
	데이터), 순서가 있기에 중복저장이 되어도 구분 가능 하기에 중복 저장가능

Set 계열 구현 클래스  - HashSet, TreeSet
Set(집합) - 주머니 모양의 집합, 순서를 유지하지 않고 저장, 마땅한 순서를 정하지 않기에
	중복 저장을 할 시 구별이 불가능하기에 중복데이터가 들어오면 자동 제거하여
	중복 저장이 안됨

Map 계열 구현 클래스 - HashMap, HashTable, TreeMap, Properties
Map(지도) - 좌표를 찍으면 주소가 나옴, Key와 Value 쌍으로 구성하여 저장, ***value는 중복
	중복저장이 가능하지만 그 값을 구별해주는 Key는 중복으로 저장 불가



Interface(접점) : 관련없는 것들을 연결
	        공통된 메서드명을 제공하여 규약을 만듬

컬렉션
String도 객체로 자연스럽게 저장되는지 확인하기

컬렉션은 객체만 저장가능 밑 Wrapper 클래스 사용
Boolean, Charater, Byte, Shor, Integer, Long, Float, Double

동기화 : 하나의 작업이 끝나기 전까지 다른일을 하지 않는것
비동기화 : 한가지 작업중 여유자원이 있을시 다른 작업도 시작하는것

자바 : 멀티스레드 지원 ( 여러 스레드를 만들어 사용 가능)
우리가 사용하는 스레드 방식은 ( main() -> 메인 쓰레드)
 -> 멀티 스레드 사용하고 싶을시
 -> Tread클래스 상속을 받아야한다
 -> 멀티스레드가 필요한 경우 : 여러작업을 동시에 처리하고 싶을 때
 ex) 대용량 데이터 처리..
 ex) UI가 응답성 유지하면서 백그라운드에서 작업을 실행하고 싶을 때
  - 파일 다운로드 중에도 사용자가 UI를 조작할 수 있게끔 할때

ArrayList : 동기화를 제공하지 않기에 만약 ArrayList를 멀티스레드 환경에서 사용 시 문제가 생길수 있다.

ArrayList : 검색이 주로 사용되는곳
Vector : List중 가장 성능이 좋지 않음
LinkedList : 삽입, 수정, 삭제가 주로 이용될 때 사용

static 예약어가 붙을 시 
클래스명.메서드명()으로 호출


case 'a' : case 'g' : case 'd' - JDK 버전 11이전
실무에서는 아직도 11이전을 많이 쓰기에 윗 방식을 이용하는게 좋음
case 'a', 'g', 'd' - JDK버전 12이상


**List<E> list = null;**
E : 제네릭, 들어올 객체타입을 제한
list.add(값); 을 실행시 nullPointError 런타임 에러 발생

list의 크기를 따질때 size()메서드 length() 아님

toString 영상 참조

new 연산자 없이 add() put()연산자 사용 불가능 이유는 참조할 Heap영역에 주소가 없는 null인 상태라 그럼

** 리스트나 set 정렬
Comparator<E> comparator = Comparator.comparing(E::getter);
Collections.sort(정렬할 목록, comparator);




List 
remove(int index) :
intdex 번호를 알아야 지울 수 있다. (단점)
인덱스번호를 알기 때문에 정호가한 요소를 지정하여 삭제가능

remove(Object o) :
인덱스 번호를 모를때 사용
- 리스트는 중복 요소 허용
- 중복된 요소가 있는 경우 처음 발견한 요소 하나만 제거
이런 차이 때문에 되도록 index번호를 이용해서 삭제 이용

List<Integer> list = new ArrayList<Integer>();

list.add(1); // 0
list.add(2); // 1
list.add(3); // 2

list.remove(1); // 인덱스 1에 있는 요소를 제거 즉 2를 제거

객체 1을 제거하고 싶으면
remove(Object o)
list.remove(Integer.valueOf(1));
// 인덱스 0에 담긴 1을 삭제


이런 차이와 모호함 속 오는 혼동 때문에 되도록 index번호를 이용해서 삭제 이용


